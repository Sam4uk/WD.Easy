# WD.Easy

Ця бібліотека призначена для керування режимами роботи сторожового таймера, поки тільки мікроконтролерів серії `AVR`.

## Особливості

Я не писав її в стилі класу синглтон (сторожовий таймер то один). Все рівно скільки об'єктів не було б створено всі вони працюватимуть з одним регістом.

## Перед історія

Всі ті бібліотеки які я знаходив не відповідали моїй основній вимозі.

__ТАЙМЕР МАЄ ПОЧАТИ ВІДЛІК ЩЕ ДО СТАРТУ ФУНКЦІЇ `setup`__

# Приклади

## Приклад перший
```cpp
void WD_tick() {
  Serial.print("WD_tick()");
  Serial.println(millis());
}

WatchDogEasy WD(WatchDogEasy::WD_1S, WatchDogEasy::INTERRUPT, WD_tick);

void setup() { Serial.begin(115200); }
void loop() {}
```
Тут ми ініціюємо таймер на спрацьовування кожну секунду, при спрацьовуванні генеруватиметься переривання, яке буде оброблятися функцією `WD_tick()`.

В цьому прикладі таймер починає відлік ще до початку роботи функції  `setup()`. Це зручно якщо при ініціації контролеру є ризик завичнути

## Приклад другий

```cpp
void WD_tick() {
  Serial.print("WD_tick()");
  Serial.println(millis());
}

WatchDogEasy WD;

void setup() { 
    Serial.begin(115200);
    WD.setTimeOut(WatchDogEasy::WD_1S); 
    WD.setMode(WatchDogEasy::INTERRUPT); 
    WD.setTask(WD_tick); 
}
void loop() {}
```

Тут все те саме, але таймер починає відлік після останнього сеттера. 

Всі сетери скидають таймер на новий відлік.
Геттери цього не роблять (Будьте уважні). Під час виконання геттеру може збігти час і виконатися дія запрограмованна у таймері.

# Керування таймером

## Методи
|       Метод         |     ОПИС                           |результат|
|---------------------|------------------------------------|-|
|`setTimeOut(uint8_t)`|Задає інтервал спрацьовувань таймеру|`void`   |
|`setMode(uint8_t)`   |Задає дію при спрацьовуванні таймеру|`void`   |
|`setTask(ptr*)`      |Задати функцію обробник переривання |`void`   |
|||                                                                  |
|`getTimeOut()`       |Отримати періодичність спрацьовуань |`uint8_t`|
|`getMode()`          |Отримати режим роботи таймеру       |`uint8_t`|
|`isEnable()`         |Чи активний таймер                  |`bool`   |
|||                                                                  |
|`reset()`            |Почати новий відлік                          ||



## Інтервали
|define  |  час| |
|--------|:---:|-|
|WD_15MS |0.015| |
|WD_30MS |0.030| |
|WD_60MS |0.060| |
|WD_120MS|0.120| |
|WD_250MS|0.250| |
|WD_500MS|0.500| |
|WD_1S   |1    | |
|WD_2S   |2    | |
|WD_4S   |2    | |
|WD_8S   |4    | |

_Примітка_ Час приблизний і не підходить для вимірювання точних інтервалів, оскільки сторожевий таймер тактується від внутрішнього низькочатоного генератора, який "пливе" при зміні напруги живлення та температури

## Дії
|define|Означення|
|-|-|
|DISABLED|Таймер зупинено|
|INTERRUPT|При спрацьовуванні буде викликано обробник переривання|
|SYSTEMRESET|При спрацьовуванні буде виконано перезавантаження мікроконтроллера|
|INTERUPTANDRESET|При спрацьовуванні буде викликано обробник переривання</br> І через такий же інтервали виконається перезавантаження контролеру|

## Обробник переривань

За замовчуванням обробникпереривань не вказаний (`nullptr`).